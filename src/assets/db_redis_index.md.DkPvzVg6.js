import{_ as a,c as i,o as t,ag as r}from"./chunks/framework.BgId8OS5.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"db/redis/index.md","filePath":"backend/db/redis/index.md"}'),d={name:"db/redis/index.md"};function o(l,e,s,n,p,c){return t(),i("div",null,e[0]||(e[0]=[r('<h2 id="单线程" tabindex="-1">单线程 <a class="header-anchor" href="#单线程" aria-label="Permalink to &quot;单线程&quot;">​</a></h2><p>redis4.0已经支持多线程了</p><p>redis的网络IO和键值对读写是由一个线程完成的</p><p>但Redis的其它功能，持久化，异步删除，集群数据同步是多个线程的</p><p>总的来说, 整个Redis来说，是多1.</p><h2 id="为什么快" tabindex="-1">为什么快 <a class="header-anchor" href="#为什么快" aria-label="Permalink to &quot;为什么快&quot;">​</a></h2><ol><li>基于内存</li><li>数据结构简单</li><li>多路复用和非阻塞IO</li><li>避免上下文切换</li></ol><p>对于Redis来说，性能的瓶颈主要是内存和网络带宽，不是CPU</p><h2 id="缓存的实现流程" tabindex="-1">缓存的实现流程 <a class="header-anchor" href="#缓存的实现流程" aria-label="Permalink to &quot;缓存的实现流程&quot;">​</a></h2><p><img src="http://pic.justdoiit.top/imgs/2024-03-01-1709262110.webp" alt="" loading="lazy"></p>',10)]))}const m=a(d,[["render",o]]);export{h as __pageData,m as default};
